use crate::sim2::state::State;
use crate::sim2::timeline::{ActionState, Timeline};
use crate::sim2::attack::{Attack, CharacterAttack, AtkQueue};
use crate::sim2::types::{CharacterAction, DamageType, Vision, FieldCharacterIndex, WeaponType, FieldEnergy, Particle, VecFieldEnergy, ToNaAction};
use crate::sim2::element::{ElementalGauge, PHYSICAL_GAUGE, PYRO_GAUGE1A, PYRO_GAUGE2B, HYDRO_GAUGE1A, HYDRO_GAUGE2B, ELECTRO_GAUGE1A, ELECTRO_GAUGE2B, CRYO_GAUGE1A, CRYO_GAUGE2B, ANEMO_GAUGE1A, ANEMO_GAUGE2B, GEO_GAUGE1A, GEO_GAUGE2B, DENDRO_GAUGE1A, DENDRO_GAUGE2B};
use crate::sim2::record::{CharacterRecord, CharacterData, Enemy};

use WeaponType::*;
use Vision::*;

// version 1.2

// Transient Blossoms generated by Abiogenesis: Solar Isotoma deal 25% more DMG
// to opponents whose HP is below 50%.

// Using Rite of Progeniture: Tectonic Tide increases the Elemental Mastery of
// nearby party members by 125 for 10s.
#[derive(Debug)]
pub struct Albedo {
    burst_time: f32,
}

impl Albedo {
    pub fn record() -> CharacterRecord {
        CharacterRecord::default()
            .name("Albedo").vision(Geo).weapon(Sword).version(1.2)
            .base_hp(13226.0).base_atk(251.0).base_def(876.0)
            .geo_dmg(28.8)
            .energy_cost(40.)
    }

    pub fn new() -> Self {
        Self {
            burst_time: -99.,
        }
    }
}

impl Timeline for Albedo {
    // perform an action
    fn decide_action(&mut self, state: &ActionState, data: &mut CharacterData) -> CharacterAction {
        // check if skill can be used
        if state.rel_time.press >= 20. {
            CharacterAction::PressSkill
        // is burst CD off and has enough energy
        } else if state.rel_time.burst >= 12. && state.energy >= 40. {
            CharacterAction::Burst
        // check if normal attacks can be used (both animations are ended)
        } else if state.rel_time.na >= 0.5134 {
            // 5 attacks in 2.567 seconds
            data.na_idx.to_na(5, state.na_carryover(0.5134))
        } else {
            CharacterAction::StandStill
        }
    }

    // generate energy and modify acceleration states according to the event
    fn accelerate(&mut self, field_energy: &mut Vec<FieldEnergy>, event: &CharacterAction, state: &mut ActionState, data: &CharacterData) -> () {
        match event {
            CharacterAction::PressSkill => field_energy.push_p(Particle::new(data.character.vision, 4.)),
            _ => (),
        }
    }
}

impl CharacterAttack for Albedo {
    fn burst(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.add_burst(660.96, &GEO_GAUGE1A, time, event, data, state);
        for i in 1..4 {
            atk_queue.add_burst(129.6, &GEO_GAUGE1A, time + i as f32, event, data, state);
        }
    }

    fn press(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.add_skill(234.72, &GEO_GAUGE1A, time, event, data, state);
        for i in 0..10 {
            atk_queue.add_skill(240.48, &GEO_GAUGE1A, time + (2 * i) as f32, event, data, state);
        }
    }

    fn na1(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.add_na(72.62, &PHYSICAL_GAUGE, time, event, data, state);
    }

    fn na2(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.add_na(72.62, &PHYSICAL_GAUGE, time, event, data, state);
    }

    fn na3(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.add_na(93.81, &PHYSICAL_GAUGE, time, event, data, state);
    }

    fn na4(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.add_na(98.35, &PHYSICAL_GAUGE, time, event, data, state);
    }

    fn na5(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.add_na(122.7, &PHYSICAL_GAUGE, time, event, data, state);
    }

    fn modify(&mut self, action_state: &ActionState, data: &CharacterData, attack: &mut Attack, state: &mut State, enemy: &mut Enemy) -> () {
        if action_state.did_burst() {
            self.burst_time = action_state.current_time;
        }
        if attack.time - self.burst_time <= 10. {
            state.em += 125.;
        }
    }

    fn reset_modify(&mut self) -> () {
        self.burst_time = -99.;
    }
}

// After firing a Frostflake Arrow, the CRIT Rate of subsequent Frostflake
// Arrows and their resulting bloom effects is increased by 20% for 5s.

// Celestial Shower grants a 20% Cryo DMG Bonus to active members in the AoE.
#[derive(Debug)]
pub struct Ganyu {
    burst_time: f32,
}

impl Ganyu {
    pub fn record() -> CharacterRecord {
        CharacterRecord::default()
            .name("Ganyu").vision(Cryo).weapon(Bow).version(1.2)
            .base_hp(9797.0).base_atk(335.0).base_def(630.0)
            .cd(88.4)
            .energy_cost(60.)
    }

    pub fn new() -> Self {
        Self {
            burst_time: -99.
        }
    }
}

impl Timeline for Ganyu {
    // perform an action
    fn decide_action(&mut self, state: &ActionState, data: &mut CharacterData) -> CharacterAction {
        // check if skill can be used
        if state.rel_time.press >= 10. {
            CharacterAction::PressSkill
        // is burst CD off and has enough energy
        } else if state.rel_time.burst >= 15. && state.energy >= 60. {
            CharacterAction::Burst
        // check if normal attacks can be used (both animations are ended)
        } else if data.idx.is_on_field() && state.rel_time.ca >= 2.266 {
            CharacterAction::Ca(state.ca_carryover(2.266))
        } else {
            CharacterAction::StandStill
        }
    }

    // generate energy and modify acceleration states according to the event
    fn accelerate(&mut self, field_energy: &mut Vec<FieldEnergy>, event: &CharacterAction, state: &mut ActionState, data: &CharacterData) -> () {
        match event {
            CharacterAction::PressSkill => field_energy.push_p(Particle::new(data.character.vision, 4.)),
            _ => (),
        }
    }
}

impl CharacterAttack for Ganyu {
    fn burst(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        for i in 0..18 {
            atk_queue.add_burst(126.49, &CRYO_GAUGE1A, time + 0.83 * i as f32, event, data, state);
        }
    }

    fn press(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.add_skill(237.6, &CRYO_GAUGE1A, time, event, data, state);
        atk_queue.add_skill(237.6, &CRYO_GAUGE1A, time+5., event, data, state);
    }

    fn ca(&mut self, time: f32, event: &CharacterAction, data: &CharacterData, atk_queue: &mut Vec<Attack>, state: &mut State, enemy: &mut Enemy) -> () {
        atk_queue.apply_ca(230.4 + 391.68, &CRYO_GAUGE1A, time, event, data, state);
    }

    fn modify(&mut self, action_state: &ActionState, data: &CharacterData, attack: &mut Attack, state: &mut State, enemy: &mut Enemy) -> () {
        if attack.idx == data.idx && attack.kind == DamageType::Ca {
            state.cr += 20.;
        }
        if action_state.did_burst() {
            self.burst_time = action_state.current_time;
        }
        if attack.time - self.burst_time <= 15. {
            state.cryo_dmg += 20.;
        }
    }

    fn reset_modify(&mut self) -> () {
        self.burst_time = -99.;
    }
}
